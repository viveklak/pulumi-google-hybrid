// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const DnsKeySpecAlgorithm = {
    Rsasha1: "RSASHA1",
    Rsasha256: "RSASHA256",
    Rsasha512: "RSASHA512",
    Ecdsap256sha256: "ECDSAP256SHA256",
    Ecdsap384sha384: "ECDSAP384SHA384",
} as const;

/**
 * String mnemonic specifying the DNSSEC algorithm of this key.
 */
export type DnsKeySpecAlgorithm = (typeof DnsKeySpecAlgorithm)[keyof typeof DnsKeySpecAlgorithm];

export const DnsKeySpecKeyType = {
    KeySigning: "KEY_SIGNING",
    ZoneSigning: "ZONE_SIGNING",
} as const;

/**
 * Specifies whether this is a key signing key (KSK) or a zone signing key (ZSK). Key signing keys have the Secure Entry Point flag set and, when active, are only used to sign resource record sets of type DNSKEY. Zone signing keys do not have the Secure Entry Point flag set and are used to sign all other types of resource record sets.
 */
export type DnsKeySpecKeyType = (typeof DnsKeySpecKeyType)[keyof typeof DnsKeySpecKeyType];

export const ManagedZoneDnsSecConfigNonExistence = {
    Nsec: "NSEC",
    Nsec3: "NSEC3",
} as const;

/**
 * Specifies the mechanism for authenticated denial-of-existence responses. Can only be changed while the state is OFF.
 */
export type ManagedZoneDnsSecConfigNonExistence = (typeof ManagedZoneDnsSecConfigNonExistence)[keyof typeof ManagedZoneDnsSecConfigNonExistence];

export const ManagedZoneDnsSecConfigState = {
    /**
     * DNSSEC is disabled; the zone is not signed.
     */
    Off: "OFF",
    /**
     * DNSSEC is enabled; the zone is signed and fully managed.
     */
    On: "ON",
    /**
     * DNSSEC is enabled, but in a "transfer" mode.
     */
    Transfer: "TRANSFER",
} as const;

/**
 * Specifies whether DNSSEC is enabled, and what mode it is in.
 */
export type ManagedZoneDnsSecConfigState = (typeof ManagedZoneDnsSecConfigState)[keyof typeof ManagedZoneDnsSecConfigState];

export const ManagedZoneForwardingConfigNameServerTargetForwardingPath = {
    /**
     * Cloud DNS makes forwarding decisions based on address ranges; that is, RFC1918 addresses forward to the target through the VPC and non-RFC1918 addresses forward to the target through the internet
     */
    Default: "DEFAULT",
    /**
     * Cloud DNS always forwards to this target through the VPC.
     */
    Private: "PRIVATE",
} as const;

/**
 * Forwarding path for this NameServerTarget. If unset or set to DEFAULT, Cloud DNS makes forwarding decisions based on IP address ranges; that is, RFC1918 addresses go to the VPC network, non-RFC1918 addresses go to the internet. When set to PRIVATE, Cloud DNS always sends queries through the VPC network for this target.
 */
export type ManagedZoneForwardingConfigNameServerTargetForwardingPath = (typeof ManagedZoneForwardingConfigNameServerTargetForwardingPath)[keyof typeof ManagedZoneForwardingConfigNameServerTargetForwardingPath];

export const ManagedZoneVisibility = {
    Public: "PUBLIC",
    Private: "PRIVATE",
} as const;

/**
 * The zone's visibility: public zones are exposed to the Internet, while private zones are visible only to Virtual Private Cloud resources.
 */
export type ManagedZoneVisibility = (typeof ManagedZoneVisibility)[keyof typeof ManagedZoneVisibility];

export const PolicyAlternativeNameServerConfigTargetNameServerForwardingPath = {
    /**
     * Cloud DNS makes forwarding decision based on IP address ranges; that is, RFC1918 addresses forward to the target through the VPC and non-RFC1918 addresses forward to the target through the internet
     */
    Default: "DEFAULT",
    /**
     * Cloud DNS always forwards to this target through the VPC.
     */
    Private: "PRIVATE",
} as const;

/**
 * Forwarding path for this TargetNameServer. If unset or set to DEFAULT, Cloud DNS makes forwarding decisions based on address ranges; that is, RFC1918 addresses go to the VPC network, non-RFC1918 addresses go to the internet. When set to PRIVATE, Cloud DNS always sends queries through the VPC network for this target.
 */
export type PolicyAlternativeNameServerConfigTargetNameServerForwardingPath = (typeof PolicyAlternativeNameServerConfigTargetNameServerForwardingPath)[keyof typeof PolicyAlternativeNameServerConfigTargetNameServerForwardingPath];

export const ResponsePolicyRuleBehavior = {
    BehaviorUnspecified: "BEHAVIOR_UNSPECIFIED",
    /**
     * Skip a less-specific ResponsePolicyRule and continue normal query logic. This can be used in conjunction with a wildcard to exempt a subset of the wildcard ResponsePolicyRule from the ResponsePolicy behavior and e.g., query the public internet instead. For instance, if these rules exist: *.example.com -> 1.2.3.4 foo.example.com -> PASSTHRU Then a query for 'foo.example.com' skips the wildcard.
     */
    BypassResponsePolicy: "BYPASS_RESPONSE_POLICY",
} as const;

/**
 * Answer this query with a behavior rather than DNS data.
 */
export type ResponsePolicyRuleBehavior = (typeof ResponsePolicyRuleBehavior)[keyof typeof ResponsePolicyRuleBehavior];
