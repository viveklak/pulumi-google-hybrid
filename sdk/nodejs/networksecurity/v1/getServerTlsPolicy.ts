// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs, enums } from "../../types";
import * as utilities from "../../utilities";

/**
 * Gets details of a single ServerTlsPolicy.
 */
export function getServerTlsPolicy(args: GetServerTlsPolicyArgs, opts?: pulumi.InvokeOptions): Promise<GetServerTlsPolicyResult> {
    if (!opts) {
        opts = {}
    }

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
    return pulumi.runtime.invoke("google-hybrid:networksecurity/v1:getServerTlsPolicy", {
        "location": args.location,
        "project": args.project,
        "serverTlsPolicyId": args.serverTlsPolicyId,
    }, opts);
}

export interface GetServerTlsPolicyArgs {
    location: string;
    project?: string;
    serverTlsPolicyId: string;
}

export interface GetServerTlsPolicyResult {
    /**
     *  Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
     */
    readonly allowOpen: boolean;
    /**
     * The timestamp when the resource was created.
     */
    readonly createTime: string;
    /**
     * Free-text description of the resource.
     */
    readonly description: string;
    /**
     * Set of label tags associated with the resource.
     */
    readonly labels: {[key: string]: string};
    /**
     *  Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections.
     */
    readonly mtlsPolicy: outputs.networksecurity.v1.MTLSPolicyResponse;
    /**
     * Name of the ServerTlsPolicy resource. It matches the pattern `projects/*&#47;locations/{location}/serverTlsPolicies/{server_tls_policy}`
     */
    readonly name: string;
    /**
     *  Defines a mechanism to provision server identity (public and private keys). Cannot be combined with `allow_open` as a permissive mode that allows both plain text and TLS is not supported.
     */
    readonly serverCertificate: outputs.networksecurity.v1.GoogleCloudNetworksecurityV1CertificateProviderResponse;
    /**
     * The timestamp when the resource was updated.
     */
    readonly updateTime: string;
}

export function getServerTlsPolicyOutput(args: GetServerTlsPolicyOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetServerTlsPolicyResult> {
    return pulumi.output(args).apply(a => getServerTlsPolicy(a, opts))
}

export interface GetServerTlsPolicyOutputArgs {
    location: pulumi.Input<string>;
    project?: pulumi.Input<string>;
    serverTlsPolicyId: pulumi.Input<string>;
}
