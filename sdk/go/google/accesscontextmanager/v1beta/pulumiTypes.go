// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevel struct {
	// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
	CombiningFunction *BasicLevelCombiningFunction `pulumi:"combiningFunction"`
	// A list of requirements for the `AccessLevel` to be granted.
	Conditions []Condition `pulumi:"conditions"`
}

// BasicLevelInput is an input type that accepts BasicLevelArgs and BasicLevelOutput values.
// You can construct a concrete instance of `BasicLevelInput` via:
//
//          BasicLevelArgs{...}
type BasicLevelInput interface {
	pulumi.Input

	ToBasicLevelOutput() BasicLevelOutput
	ToBasicLevelOutputWithContext(context.Context) BasicLevelOutput
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelArgs struct {
	// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
	CombiningFunction BasicLevelCombiningFunctionPtrInput `pulumi:"combiningFunction"`
	// A list of requirements for the `AccessLevel` to be granted.
	Conditions ConditionArrayInput `pulumi:"conditions"`
}

func (BasicLevelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicLevel)(nil)).Elem()
}

func (i BasicLevelArgs) ToBasicLevelOutput() BasicLevelOutput {
	return i.ToBasicLevelOutputWithContext(context.Background())
}

func (i BasicLevelArgs) ToBasicLevelOutputWithContext(ctx context.Context) BasicLevelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicLevelOutput)
}

func (i BasicLevelArgs) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return i.ToBasicLevelPtrOutputWithContext(context.Background())
}

func (i BasicLevelArgs) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicLevelOutput).ToBasicLevelPtrOutputWithContext(ctx)
}

// BasicLevelPtrInput is an input type that accepts BasicLevelArgs, BasicLevelPtr and BasicLevelPtrOutput values.
// You can construct a concrete instance of `BasicLevelPtrInput` via:
//
//          BasicLevelArgs{...}
//
//  or:
//
//          nil
type BasicLevelPtrInput interface {
	pulumi.Input

	ToBasicLevelPtrOutput() BasicLevelPtrOutput
	ToBasicLevelPtrOutputWithContext(context.Context) BasicLevelPtrOutput
}

type basicLevelPtrType BasicLevelArgs

func BasicLevelPtr(v *BasicLevelArgs) BasicLevelPtrInput {
	return (*basicLevelPtrType)(v)
}

func (*basicLevelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicLevel)(nil)).Elem()
}

func (i *basicLevelPtrType) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return i.ToBasicLevelPtrOutputWithContext(context.Background())
}

func (i *basicLevelPtrType) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicLevelPtrOutput)
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelOutput struct{ *pulumi.OutputState }

func (BasicLevelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicLevel)(nil)).Elem()
}

func (o BasicLevelOutput) ToBasicLevelOutput() BasicLevelOutput {
	return o
}

func (o BasicLevelOutput) ToBasicLevelOutputWithContext(ctx context.Context) BasicLevelOutput {
	return o
}

func (o BasicLevelOutput) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return o.ToBasicLevelPtrOutputWithContext(context.Background())
}

func (o BasicLevelOutput) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicLevel) *BasicLevel {
		return &v
	}).(BasicLevelPtrOutput)
}

// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
func (o BasicLevelOutput) CombiningFunction() BasicLevelCombiningFunctionPtrOutput {
	return o.ApplyT(func(v BasicLevel) *BasicLevelCombiningFunction { return v.CombiningFunction }).(BasicLevelCombiningFunctionPtrOutput)
}

// A list of requirements for the `AccessLevel` to be granted.
func (o BasicLevelOutput) Conditions() ConditionArrayOutput {
	return o.ApplyT(func(v BasicLevel) []Condition { return v.Conditions }).(ConditionArrayOutput)
}

type BasicLevelPtrOutput struct{ *pulumi.OutputState }

func (BasicLevelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicLevel)(nil)).Elem()
}

func (o BasicLevelPtrOutput) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return o
}

func (o BasicLevelPtrOutput) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return o
}

func (o BasicLevelPtrOutput) Elem() BasicLevelOutput {
	return o.ApplyT(func(v *BasicLevel) BasicLevel {
		if v != nil {
			return *v
		}
		var ret BasicLevel
		return ret
	}).(BasicLevelOutput)
}

// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
func (o BasicLevelPtrOutput) CombiningFunction() BasicLevelCombiningFunctionPtrOutput {
	return o.ApplyT(func(v *BasicLevel) *BasicLevelCombiningFunction {
		if v == nil {
			return nil
		}
		return v.CombiningFunction
	}).(BasicLevelCombiningFunctionPtrOutput)
}

// A list of requirements for the `AccessLevel` to be granted.
func (o BasicLevelPtrOutput) Conditions() ConditionArrayOutput {
	return o.ApplyT(func(v *BasicLevel) []Condition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(ConditionArrayOutput)
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelResponse struct {
	// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
	CombiningFunction string `pulumi:"combiningFunction"`
	// A list of requirements for the `AccessLevel` to be granted.
	Conditions []ConditionResponse `pulumi:"conditions"`
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelResponseOutput struct{ *pulumi.OutputState }

func (BasicLevelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicLevelResponse)(nil)).Elem()
}

func (o BasicLevelResponseOutput) ToBasicLevelResponseOutput() BasicLevelResponseOutput {
	return o
}

func (o BasicLevelResponseOutput) ToBasicLevelResponseOutputWithContext(ctx context.Context) BasicLevelResponseOutput {
	return o
}

// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
func (o BasicLevelResponseOutput) CombiningFunction() pulumi.StringOutput {
	return o.ApplyT(func(v BasicLevelResponse) string { return v.CombiningFunction }).(pulumi.StringOutput)
}

// A list of requirements for the `AccessLevel` to be granted.
func (o BasicLevelResponseOutput) Conditions() ConditionResponseArrayOutput {
	return o.ApplyT(func(v BasicLevelResponse) []ConditionResponse { return v.Conditions }).(ConditionResponseArrayOutput)
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type Condition struct {
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
	DevicePolicy *DevicePolicy `pulumi:"devicePolicy"`
	// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks []string `pulumi:"ipSubnetworks"`
	// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
	Members []string `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
	Negate *bool `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
	Regions []string `pulumi:"regions"`
	// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
	RequiredAccessLevels []string `pulumi:"requiredAccessLevels"`
}

// ConditionInput is an input type that accepts ConditionArgs and ConditionOutput values.
// You can construct a concrete instance of `ConditionInput` via:
//
//          ConditionArgs{...}
type ConditionInput interface {
	pulumi.Input

	ToConditionOutput() ConditionOutput
	ToConditionOutputWithContext(context.Context) ConditionOutput
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionArgs struct {
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
	DevicePolicy DevicePolicyPtrInput `pulumi:"devicePolicy"`
	// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks pulumi.StringArrayInput `pulumi:"ipSubnetworks"`
	// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
	Negate pulumi.BoolPtrInput `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
	Regions pulumi.StringArrayInput `pulumi:"regions"`
	// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
	RequiredAccessLevels pulumi.StringArrayInput `pulumi:"requiredAccessLevels"`
}

func (ConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (i ConditionArgs) ToConditionOutput() ConditionOutput {
	return i.ToConditionOutputWithContext(context.Background())
}

func (i ConditionArgs) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionOutput)
}

// ConditionArrayInput is an input type that accepts ConditionArray and ConditionArrayOutput values.
// You can construct a concrete instance of `ConditionArrayInput` via:
//
//          ConditionArray{ ConditionArgs{...} }
type ConditionArrayInput interface {
	pulumi.Input

	ToConditionArrayOutput() ConditionArrayOutput
	ToConditionArrayOutputWithContext(context.Context) ConditionArrayOutput
}

type ConditionArray []ConditionInput

func (ConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (i ConditionArray) ToConditionArrayOutput() ConditionArrayOutput {
	return i.ToConditionArrayOutputWithContext(context.Background())
}

func (i ConditionArray) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionArrayOutput)
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionOutput struct{ *pulumi.OutputState }

func (ConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (o ConditionOutput) ToConditionOutput() ConditionOutput {
	return o
}

func (o ConditionOutput) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return o
}

// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
func (o ConditionOutput) DevicePolicy() DevicePolicyPtrOutput {
	return o.ApplyT(func(v Condition) *DevicePolicy { return v.DevicePolicy }).(DevicePolicyPtrOutput)
}

// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
func (o ConditionOutput) IpSubnetworks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.IpSubnetworks }).(pulumi.StringArrayOutput)
}

// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
func (o ConditionOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
func (o ConditionOutput) Negate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Condition) *bool { return v.Negate }).(pulumi.BoolPtrOutput)
}

// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
func (o ConditionOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.Regions }).(pulumi.StringArrayOutput)
}

// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
func (o ConditionOutput) RequiredAccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.RequiredAccessLevels }).(pulumi.StringArrayOutput)
}

type ConditionArrayOutput struct{ *pulumi.OutputState }

func (ConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (o ConditionArrayOutput) ToConditionArrayOutput() ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) Index(i pulumi.IntInput) ConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Condition {
		return vs[0].([]Condition)[vs[1].(int)]
	}).(ConditionOutput)
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionResponse struct {
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
	DevicePolicy DevicePolicyResponse `pulumi:"devicePolicy"`
	// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks []string `pulumi:"ipSubnetworks"`
	// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
	Members []string `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
	Negate bool `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
	Regions []string `pulumi:"regions"`
	// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
	RequiredAccessLevels []string `pulumi:"requiredAccessLevels"`
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionResponseOutput struct{ *pulumi.OutputState }

func (ConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseOutput) ToConditionResponseOutput() ConditionResponseOutput {
	return o
}

func (o ConditionResponseOutput) ToConditionResponseOutputWithContext(ctx context.Context) ConditionResponseOutput {
	return o
}

// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
func (o ConditionResponseOutput) DevicePolicy() DevicePolicyResponseOutput {
	return o.ApplyT(func(v ConditionResponse) DevicePolicyResponse { return v.DevicePolicy }).(DevicePolicyResponseOutput)
}

// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
func (o ConditionResponseOutput) IpSubnetworks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.IpSubnetworks }).(pulumi.StringArrayOutput)
}

// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
func (o ConditionResponseOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
func (o ConditionResponseOutput) Negate() pulumi.BoolOutput {
	return o.ApplyT(func(v ConditionResponse) bool { return v.Negate }).(pulumi.BoolOutput)
}

// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
func (o ConditionResponseOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.Regions }).(pulumi.StringArrayOutput)
}

// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
func (o ConditionResponseOutput) RequiredAccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.RequiredAccessLevels }).(pulumi.StringArrayOutput)
}

type ConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (ConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutput() ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutputWithContext(ctx context.Context) ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) Index(i pulumi.IntInput) ConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ConditionResponse {
		return vs[0].([]ConditionResponse)[vs[1].(int)]
	}).(ConditionResponseOutput)
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevel struct {
	// A Cloud CEL expression evaluating to a boolean.
	Expr Expr `pulumi:"expr"`
}

// CustomLevelInput is an input type that accepts CustomLevelArgs and CustomLevelOutput values.
// You can construct a concrete instance of `CustomLevelInput` via:
//
//          CustomLevelArgs{...}
type CustomLevelInput interface {
	pulumi.Input

	ToCustomLevelOutput() CustomLevelOutput
	ToCustomLevelOutputWithContext(context.Context) CustomLevelOutput
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelArgs struct {
	// A Cloud CEL expression evaluating to a boolean.
	Expr ExprInput `pulumi:"expr"`
}

func (CustomLevelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomLevel)(nil)).Elem()
}

func (i CustomLevelArgs) ToCustomLevelOutput() CustomLevelOutput {
	return i.ToCustomLevelOutputWithContext(context.Background())
}

func (i CustomLevelArgs) ToCustomLevelOutputWithContext(ctx context.Context) CustomLevelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomLevelOutput)
}

func (i CustomLevelArgs) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return i.ToCustomLevelPtrOutputWithContext(context.Background())
}

func (i CustomLevelArgs) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomLevelOutput).ToCustomLevelPtrOutputWithContext(ctx)
}

// CustomLevelPtrInput is an input type that accepts CustomLevelArgs, CustomLevelPtr and CustomLevelPtrOutput values.
// You can construct a concrete instance of `CustomLevelPtrInput` via:
//
//          CustomLevelArgs{...}
//
//  or:
//
//          nil
type CustomLevelPtrInput interface {
	pulumi.Input

	ToCustomLevelPtrOutput() CustomLevelPtrOutput
	ToCustomLevelPtrOutputWithContext(context.Context) CustomLevelPtrOutput
}

type customLevelPtrType CustomLevelArgs

func CustomLevelPtr(v *CustomLevelArgs) CustomLevelPtrInput {
	return (*customLevelPtrType)(v)
}

func (*customLevelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomLevel)(nil)).Elem()
}

func (i *customLevelPtrType) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return i.ToCustomLevelPtrOutputWithContext(context.Background())
}

func (i *customLevelPtrType) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomLevelPtrOutput)
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelOutput struct{ *pulumi.OutputState }

func (CustomLevelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomLevel)(nil)).Elem()
}

func (o CustomLevelOutput) ToCustomLevelOutput() CustomLevelOutput {
	return o
}

func (o CustomLevelOutput) ToCustomLevelOutputWithContext(ctx context.Context) CustomLevelOutput {
	return o
}

func (o CustomLevelOutput) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return o.ToCustomLevelPtrOutputWithContext(context.Background())
}

func (o CustomLevelOutput) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CustomLevel) *CustomLevel {
		return &v
	}).(CustomLevelPtrOutput)
}

// A Cloud CEL expression evaluating to a boolean.
func (o CustomLevelOutput) Expr() ExprOutput {
	return o.ApplyT(func(v CustomLevel) Expr { return v.Expr }).(ExprOutput)
}

type CustomLevelPtrOutput struct{ *pulumi.OutputState }

func (CustomLevelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomLevel)(nil)).Elem()
}

func (o CustomLevelPtrOutput) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return o
}

func (o CustomLevelPtrOutput) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return o
}

func (o CustomLevelPtrOutput) Elem() CustomLevelOutput {
	return o.ApplyT(func(v *CustomLevel) CustomLevel {
		if v != nil {
			return *v
		}
		var ret CustomLevel
		return ret
	}).(CustomLevelOutput)
}

// A Cloud CEL expression evaluating to a boolean.
func (o CustomLevelPtrOutput) Expr() ExprPtrOutput {
	return o.ApplyT(func(v *CustomLevel) *Expr {
		if v == nil {
			return nil
		}
		return &v.Expr
	}).(ExprPtrOutput)
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelResponse struct {
	// A Cloud CEL expression evaluating to a boolean.
	Expr ExprResponse `pulumi:"expr"`
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelResponseOutput struct{ *pulumi.OutputState }

func (CustomLevelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomLevelResponse)(nil)).Elem()
}

func (o CustomLevelResponseOutput) ToCustomLevelResponseOutput() CustomLevelResponseOutput {
	return o
}

func (o CustomLevelResponseOutput) ToCustomLevelResponseOutputWithContext(ctx context.Context) CustomLevelResponseOutput {
	return o
}

// A Cloud CEL expression evaluating to a boolean.
func (o CustomLevelResponseOutput) Expr() ExprResponseOutput {
	return o.ApplyT(func(v CustomLevelResponse) ExprResponse { return v.Expr }).(ExprResponseOutput)
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicy struct {
	// Allowed device management levels, an empty list allows all management levels.
	AllowedDeviceManagementLevels []DevicePolicyAllowedDeviceManagementLevelsItem `pulumi:"allowedDeviceManagementLevels"`
	// Allowed encryptions statuses, an empty list allows all statuses.
	AllowedEncryptionStatuses []DevicePolicyAllowedEncryptionStatusesItem `pulumi:"allowedEncryptionStatuses"`
	// Allowed OS versions, an empty list allows all types and all versions.
	OsConstraints []OsConstraint `pulumi:"osConstraints"`
	// Whether the device needs to be approved by the customer admin.
	RequireAdminApproval *bool `pulumi:"requireAdminApproval"`
	// Whether the device needs to be corp owned.
	RequireCorpOwned *bool `pulumi:"requireCorpOwned"`
	// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
	RequireScreenlock *bool `pulumi:"requireScreenlock"`
}

// DevicePolicyInput is an input type that accepts DevicePolicyArgs and DevicePolicyOutput values.
// You can construct a concrete instance of `DevicePolicyInput` via:
//
//          DevicePolicyArgs{...}
type DevicePolicyInput interface {
	pulumi.Input

	ToDevicePolicyOutput() DevicePolicyOutput
	ToDevicePolicyOutputWithContext(context.Context) DevicePolicyOutput
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyArgs struct {
	// Allowed device management levels, an empty list allows all management levels.
	AllowedDeviceManagementLevels DevicePolicyAllowedDeviceManagementLevelsItemArrayInput `pulumi:"allowedDeviceManagementLevels"`
	// Allowed encryptions statuses, an empty list allows all statuses.
	AllowedEncryptionStatuses DevicePolicyAllowedEncryptionStatusesItemArrayInput `pulumi:"allowedEncryptionStatuses"`
	// Allowed OS versions, an empty list allows all types and all versions.
	OsConstraints OsConstraintArrayInput `pulumi:"osConstraints"`
	// Whether the device needs to be approved by the customer admin.
	RequireAdminApproval pulumi.BoolPtrInput `pulumi:"requireAdminApproval"`
	// Whether the device needs to be corp owned.
	RequireCorpOwned pulumi.BoolPtrInput `pulumi:"requireCorpOwned"`
	// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
	RequireScreenlock pulumi.BoolPtrInput `pulumi:"requireScreenlock"`
}

func (DevicePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePolicy)(nil)).Elem()
}

func (i DevicePolicyArgs) ToDevicePolicyOutput() DevicePolicyOutput {
	return i.ToDevicePolicyOutputWithContext(context.Background())
}

func (i DevicePolicyArgs) ToDevicePolicyOutputWithContext(ctx context.Context) DevicePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePolicyOutput)
}

func (i DevicePolicyArgs) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return i.ToDevicePolicyPtrOutputWithContext(context.Background())
}

func (i DevicePolicyArgs) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePolicyOutput).ToDevicePolicyPtrOutputWithContext(ctx)
}

// DevicePolicyPtrInput is an input type that accepts DevicePolicyArgs, DevicePolicyPtr and DevicePolicyPtrOutput values.
// You can construct a concrete instance of `DevicePolicyPtrInput` via:
//
//          DevicePolicyArgs{...}
//
//  or:
//
//          nil
type DevicePolicyPtrInput interface {
	pulumi.Input

	ToDevicePolicyPtrOutput() DevicePolicyPtrOutput
	ToDevicePolicyPtrOutputWithContext(context.Context) DevicePolicyPtrOutput
}

type devicePolicyPtrType DevicePolicyArgs

func DevicePolicyPtr(v *DevicePolicyArgs) DevicePolicyPtrInput {
	return (*devicePolicyPtrType)(v)
}

func (*devicePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DevicePolicy)(nil)).Elem()
}

func (i *devicePolicyPtrType) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return i.ToDevicePolicyPtrOutputWithContext(context.Background())
}

func (i *devicePolicyPtrType) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePolicyPtrOutput)
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyOutput struct{ *pulumi.OutputState }

func (DevicePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePolicy)(nil)).Elem()
}

func (o DevicePolicyOutput) ToDevicePolicyOutput() DevicePolicyOutput {
	return o
}

func (o DevicePolicyOutput) ToDevicePolicyOutputWithContext(ctx context.Context) DevicePolicyOutput {
	return o
}

func (o DevicePolicyOutput) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return o.ToDevicePolicyPtrOutputWithContext(context.Background())
}

func (o DevicePolicyOutput) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DevicePolicy) *DevicePolicy {
		return &v
	}).(DevicePolicyPtrOutput)
}

// Allowed device management levels, an empty list allows all management levels.
func (o DevicePolicyOutput) AllowedDeviceManagementLevels() DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput {
	return o.ApplyT(func(v DevicePolicy) []DevicePolicyAllowedDeviceManagementLevelsItem {
		return v.AllowedDeviceManagementLevels
	}).(DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput)
}

// Allowed encryptions statuses, an empty list allows all statuses.
func (o DevicePolicyOutput) AllowedEncryptionStatuses() DevicePolicyAllowedEncryptionStatusesItemArrayOutput {
	return o.ApplyT(func(v DevicePolicy) []DevicePolicyAllowedEncryptionStatusesItem { return v.AllowedEncryptionStatuses }).(DevicePolicyAllowedEncryptionStatusesItemArrayOutput)
}

// Allowed OS versions, an empty list allows all types and all versions.
func (o DevicePolicyOutput) OsConstraints() OsConstraintArrayOutput {
	return o.ApplyT(func(v DevicePolicy) []OsConstraint { return v.OsConstraints }).(OsConstraintArrayOutput)
}

// Whether the device needs to be approved by the customer admin.
func (o DevicePolicyOutput) RequireAdminApproval() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DevicePolicy) *bool { return v.RequireAdminApproval }).(pulumi.BoolPtrOutput)
}

// Whether the device needs to be corp owned.
func (o DevicePolicyOutput) RequireCorpOwned() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DevicePolicy) *bool { return v.RequireCorpOwned }).(pulumi.BoolPtrOutput)
}

// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
func (o DevicePolicyOutput) RequireScreenlock() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DevicePolicy) *bool { return v.RequireScreenlock }).(pulumi.BoolPtrOutput)
}

type DevicePolicyPtrOutput struct{ *pulumi.OutputState }

func (DevicePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DevicePolicy)(nil)).Elem()
}

func (o DevicePolicyPtrOutput) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return o
}

func (o DevicePolicyPtrOutput) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return o
}

func (o DevicePolicyPtrOutput) Elem() DevicePolicyOutput {
	return o.ApplyT(func(v *DevicePolicy) DevicePolicy {
		if v != nil {
			return *v
		}
		var ret DevicePolicy
		return ret
	}).(DevicePolicyOutput)
}

// Allowed device management levels, an empty list allows all management levels.
func (o DevicePolicyPtrOutput) AllowedDeviceManagementLevels() DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput {
	return o.ApplyT(func(v *DevicePolicy) []DevicePolicyAllowedDeviceManagementLevelsItem {
		if v == nil {
			return nil
		}
		return v.AllowedDeviceManagementLevels
	}).(DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput)
}

// Allowed encryptions statuses, an empty list allows all statuses.
func (o DevicePolicyPtrOutput) AllowedEncryptionStatuses() DevicePolicyAllowedEncryptionStatusesItemArrayOutput {
	return o.ApplyT(func(v *DevicePolicy) []DevicePolicyAllowedEncryptionStatusesItem {
		if v == nil {
			return nil
		}
		return v.AllowedEncryptionStatuses
	}).(DevicePolicyAllowedEncryptionStatusesItemArrayOutput)
}

// Allowed OS versions, an empty list allows all types and all versions.
func (o DevicePolicyPtrOutput) OsConstraints() OsConstraintArrayOutput {
	return o.ApplyT(func(v *DevicePolicy) []OsConstraint {
		if v == nil {
			return nil
		}
		return v.OsConstraints
	}).(OsConstraintArrayOutput)
}

// Whether the device needs to be approved by the customer admin.
func (o DevicePolicyPtrOutput) RequireAdminApproval() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DevicePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RequireAdminApproval
	}).(pulumi.BoolPtrOutput)
}

// Whether the device needs to be corp owned.
func (o DevicePolicyPtrOutput) RequireCorpOwned() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DevicePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RequireCorpOwned
	}).(pulumi.BoolPtrOutput)
}

// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
func (o DevicePolicyPtrOutput) RequireScreenlock() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DevicePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RequireScreenlock
	}).(pulumi.BoolPtrOutput)
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyResponse struct {
	// Allowed device management levels, an empty list allows all management levels.
	AllowedDeviceManagementLevels []string `pulumi:"allowedDeviceManagementLevels"`
	// Allowed encryptions statuses, an empty list allows all statuses.
	AllowedEncryptionStatuses []string `pulumi:"allowedEncryptionStatuses"`
	// Allowed OS versions, an empty list allows all types and all versions.
	OsConstraints []OsConstraintResponse `pulumi:"osConstraints"`
	// Whether the device needs to be approved by the customer admin.
	RequireAdminApproval bool `pulumi:"requireAdminApproval"`
	// Whether the device needs to be corp owned.
	RequireCorpOwned bool `pulumi:"requireCorpOwned"`
	// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
	RequireScreenlock bool `pulumi:"requireScreenlock"`
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyResponseOutput struct{ *pulumi.OutputState }

func (DevicePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePolicyResponse)(nil)).Elem()
}

func (o DevicePolicyResponseOutput) ToDevicePolicyResponseOutput() DevicePolicyResponseOutput {
	return o
}

func (o DevicePolicyResponseOutput) ToDevicePolicyResponseOutputWithContext(ctx context.Context) DevicePolicyResponseOutput {
	return o
}

// Allowed device management levels, an empty list allows all management levels.
func (o DevicePolicyResponseOutput) AllowedDeviceManagementLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DevicePolicyResponse) []string { return v.AllowedDeviceManagementLevels }).(pulumi.StringArrayOutput)
}

// Allowed encryptions statuses, an empty list allows all statuses.
func (o DevicePolicyResponseOutput) AllowedEncryptionStatuses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DevicePolicyResponse) []string { return v.AllowedEncryptionStatuses }).(pulumi.StringArrayOutput)
}

// Allowed OS versions, an empty list allows all types and all versions.
func (o DevicePolicyResponseOutput) OsConstraints() OsConstraintResponseArrayOutput {
	return o.ApplyT(func(v DevicePolicyResponse) []OsConstraintResponse { return v.OsConstraints }).(OsConstraintResponseArrayOutput)
}

// Whether the device needs to be approved by the customer admin.
func (o DevicePolicyResponseOutput) RequireAdminApproval() pulumi.BoolOutput {
	return o.ApplyT(func(v DevicePolicyResponse) bool { return v.RequireAdminApproval }).(pulumi.BoolOutput)
}

// Whether the device needs to be corp owned.
func (o DevicePolicyResponseOutput) RequireCorpOwned() pulumi.BoolOutput {
	return o.ApplyT(func(v DevicePolicyResponse) bool { return v.RequireCorpOwned }).(pulumi.BoolOutput)
}

// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
func (o DevicePolicyResponseOutput) RequireScreenlock() pulumi.BoolOutput {
	return o.ApplyT(func(v DevicePolicyResponse) bool { return v.RequireScreenlock }).(pulumi.BoolOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//          ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//          ExprArgs{...}
//
//  or:
//
//          nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr {
		if v != nil {
			return *v
		}
		var ret Expr
		return ret
	}).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponse struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title string `pulumi:"title"`
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseOutput struct{ *pulumi.OutputState }

func (ExprResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (o ExprResponseOutput) ToExprResponseOutput() ExprResponseOutput {
	return o
}

func (o ExprResponseOutput) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return o
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprResponseOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Expression }).(pulumi.StringOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Location }).(pulumi.StringOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Title }).(pulumi.StringOutput)
}

// A restriction on the OS type and version of devices making requests.
type OsConstraint struct {
	// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
	MinimumVersion *string `pulumi:"minimumVersion"`
	// The allowed OS type.
	OsType OsConstraintOsType `pulumi:"osType"`
	// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
	RequireVerifiedChromeOs *bool `pulumi:"requireVerifiedChromeOs"`
}

// OsConstraintInput is an input type that accepts OsConstraintArgs and OsConstraintOutput values.
// You can construct a concrete instance of `OsConstraintInput` via:
//
//          OsConstraintArgs{...}
type OsConstraintInput interface {
	pulumi.Input

	ToOsConstraintOutput() OsConstraintOutput
	ToOsConstraintOutputWithContext(context.Context) OsConstraintOutput
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintArgs struct {
	// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
	MinimumVersion pulumi.StringPtrInput `pulumi:"minimumVersion"`
	// The allowed OS type.
	OsType OsConstraintOsTypeInput `pulumi:"osType"`
	// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
	RequireVerifiedChromeOs pulumi.BoolPtrInput `pulumi:"requireVerifiedChromeOs"`
}

func (OsConstraintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OsConstraint)(nil)).Elem()
}

func (i OsConstraintArgs) ToOsConstraintOutput() OsConstraintOutput {
	return i.ToOsConstraintOutputWithContext(context.Background())
}

func (i OsConstraintArgs) ToOsConstraintOutputWithContext(ctx context.Context) OsConstraintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsConstraintOutput)
}

// OsConstraintArrayInput is an input type that accepts OsConstraintArray and OsConstraintArrayOutput values.
// You can construct a concrete instance of `OsConstraintArrayInput` via:
//
//          OsConstraintArray{ OsConstraintArgs{...} }
type OsConstraintArrayInput interface {
	pulumi.Input

	ToOsConstraintArrayOutput() OsConstraintArrayOutput
	ToOsConstraintArrayOutputWithContext(context.Context) OsConstraintArrayOutput
}

type OsConstraintArray []OsConstraintInput

func (OsConstraintArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OsConstraint)(nil)).Elem()
}

func (i OsConstraintArray) ToOsConstraintArrayOutput() OsConstraintArrayOutput {
	return i.ToOsConstraintArrayOutputWithContext(context.Background())
}

func (i OsConstraintArray) ToOsConstraintArrayOutputWithContext(ctx context.Context) OsConstraintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsConstraintArrayOutput)
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintOutput struct{ *pulumi.OutputState }

func (OsConstraintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OsConstraint)(nil)).Elem()
}

func (o OsConstraintOutput) ToOsConstraintOutput() OsConstraintOutput {
	return o
}

func (o OsConstraintOutput) ToOsConstraintOutputWithContext(ctx context.Context) OsConstraintOutput {
	return o
}

// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
func (o OsConstraintOutput) MinimumVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OsConstraint) *string { return v.MinimumVersion }).(pulumi.StringPtrOutput)
}

// The allowed OS type.
func (o OsConstraintOutput) OsType() OsConstraintOsTypeOutput {
	return o.ApplyT(func(v OsConstraint) OsConstraintOsType { return v.OsType }).(OsConstraintOsTypeOutput)
}

// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
func (o OsConstraintOutput) RequireVerifiedChromeOs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OsConstraint) *bool { return v.RequireVerifiedChromeOs }).(pulumi.BoolPtrOutput)
}

type OsConstraintArrayOutput struct{ *pulumi.OutputState }

func (OsConstraintArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OsConstraint)(nil)).Elem()
}

func (o OsConstraintArrayOutput) ToOsConstraintArrayOutput() OsConstraintArrayOutput {
	return o
}

func (o OsConstraintArrayOutput) ToOsConstraintArrayOutputWithContext(ctx context.Context) OsConstraintArrayOutput {
	return o
}

func (o OsConstraintArrayOutput) Index(i pulumi.IntInput) OsConstraintOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OsConstraint {
		return vs[0].([]OsConstraint)[vs[1].(int)]
	}).(OsConstraintOutput)
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintResponse struct {
	// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
	MinimumVersion string `pulumi:"minimumVersion"`
	// The allowed OS type.
	OsType string `pulumi:"osType"`
	// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
	RequireVerifiedChromeOs bool `pulumi:"requireVerifiedChromeOs"`
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintResponseOutput struct{ *pulumi.OutputState }

func (OsConstraintResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OsConstraintResponse)(nil)).Elem()
}

func (o OsConstraintResponseOutput) ToOsConstraintResponseOutput() OsConstraintResponseOutput {
	return o
}

func (o OsConstraintResponseOutput) ToOsConstraintResponseOutputWithContext(ctx context.Context) OsConstraintResponseOutput {
	return o
}

// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
func (o OsConstraintResponseOutput) MinimumVersion() pulumi.StringOutput {
	return o.ApplyT(func(v OsConstraintResponse) string { return v.MinimumVersion }).(pulumi.StringOutput)
}

// The allowed OS type.
func (o OsConstraintResponseOutput) OsType() pulumi.StringOutput {
	return o.ApplyT(func(v OsConstraintResponse) string { return v.OsType }).(pulumi.StringOutput)
}

// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
func (o OsConstraintResponseOutput) RequireVerifiedChromeOs() pulumi.BoolOutput {
	return o.ApplyT(func(v OsConstraintResponse) bool { return v.RequireVerifiedChromeOs }).(pulumi.BoolOutput)
}

type OsConstraintResponseArrayOutput struct{ *pulumi.OutputState }

func (OsConstraintResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OsConstraintResponse)(nil)).Elem()
}

func (o OsConstraintResponseArrayOutput) ToOsConstraintResponseArrayOutput() OsConstraintResponseArrayOutput {
	return o
}

func (o OsConstraintResponseArrayOutput) ToOsConstraintResponseArrayOutputWithContext(ctx context.Context) OsConstraintResponseArrayOutput {
	return o
}

func (o OsConstraintResponseArrayOutput) Index(i pulumi.IntInput) OsConstraintResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OsConstraintResponse {
		return vs[0].([]OsConstraintResponse)[vs[1].(int)]
	}).(OsConstraintResponseOutput)
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfig struct {
	// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
	AccessLevels []string `pulumi:"accessLevels"`
	// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
	Resources []string `pulumi:"resources"`
	// Google Cloud services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
	RestrictedServices []string `pulumi:"restrictedServices"`
	// Google Cloud services that are not subject to the Service Perimeter restrictions. Deprecated. Must be set to a single wildcard "*". The wildcard means that unless explicitly specified by "restricted_services" list, any service is treated as unrestricted.
	//
	// Deprecated: Google Cloud services that are not subject to the Service Perimeter restrictions. Deprecated. Must be set to a single wildcard "*". The wildcard means that unless explicitly specified by "restricted_services" list, any service is treated as unrestricted.
	UnrestrictedServices []string `pulumi:"unrestrictedServices"`
	// Beta. Configuration for APIs allowed within Perimeter.
	VpcAccessibleServices *VpcAccessibleServices `pulumi:"vpcAccessibleServices"`
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfigResponse struct {
	// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
	AccessLevels []string `pulumi:"accessLevels"`
	// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
	Resources []string `pulumi:"resources"`
	// Google Cloud services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
	RestrictedServices []string `pulumi:"restrictedServices"`
	// Google Cloud services that are not subject to the Service Perimeter restrictions. Deprecated. Must be set to a single wildcard "*". The wildcard means that unless explicitly specified by "restricted_services" list, any service is treated as unrestricted.
	//
	// Deprecated: Google Cloud services that are not subject to the Service Perimeter restrictions. Deprecated. Must be set to a single wildcard "*". The wildcard means that unless explicitly specified by "restricted_services" list, any service is treated as unrestricted.
	UnrestrictedServices []string `pulumi:"unrestrictedServices"`
	// Beta. Configuration for APIs allowed within Perimeter.
	VpcAccessibleServices VpcAccessibleServicesResponse `pulumi:"vpcAccessibleServices"`
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfigResponseOutput struct{ *pulumi.OutputState }

func (ServicePerimeterConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePerimeterConfigResponse)(nil)).Elem()
}

func (o ServicePerimeterConfigResponseOutput) ToServicePerimeterConfigResponseOutput() ServicePerimeterConfigResponseOutput {
	return o
}

func (o ServicePerimeterConfigResponseOutput) ToServicePerimeterConfigResponseOutputWithContext(ctx context.Context) ServicePerimeterConfigResponseOutput {
	return o
}

// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
func (o ServicePerimeterConfigResponseOutput) AccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.AccessLevels }).(pulumi.StringArrayOutput)
}

// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
func (o ServicePerimeterConfigResponseOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// Google Cloud services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
func (o ServicePerimeterConfigResponseOutput) RestrictedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.RestrictedServices }).(pulumi.StringArrayOutput)
}

// Google Cloud services that are not subject to the Service Perimeter restrictions. Deprecated. Must be set to a single wildcard "*". The wildcard means that unless explicitly specified by "restricted_services" list, any service is treated as unrestricted.
//
// Deprecated: Google Cloud services that are not subject to the Service Perimeter restrictions. Deprecated. Must be set to a single wildcard "*". The wildcard means that unless explicitly specified by "restricted_services" list, any service is treated as unrestricted.
func (o ServicePerimeterConfigResponseOutput) UnrestrictedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.UnrestrictedServices }).(pulumi.StringArrayOutput)
}

// Beta. Configuration for APIs allowed within Perimeter.
func (o ServicePerimeterConfigResponseOutput) VpcAccessibleServices() VpcAccessibleServicesResponseOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) VpcAccessibleServicesResponse { return v.VpcAccessibleServices }).(VpcAccessibleServicesResponseOutput)
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServices struct {
	// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
	AllowedServices []string `pulumi:"allowedServices"`
	// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
	EnableRestriction *bool `pulumi:"enableRestriction"`
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServicesResponse struct {
	// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
	AllowedServices []string `pulumi:"allowedServices"`
	// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
	EnableRestriction bool `pulumi:"enableRestriction"`
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServicesResponseOutput struct{ *pulumi.OutputState }

func (VpcAccessibleServicesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcAccessibleServicesResponse)(nil)).Elem()
}

func (o VpcAccessibleServicesResponseOutput) ToVpcAccessibleServicesResponseOutput() VpcAccessibleServicesResponseOutput {
	return o
}

func (o VpcAccessibleServicesResponseOutput) ToVpcAccessibleServicesResponseOutputWithContext(ctx context.Context) VpcAccessibleServicesResponseOutput {
	return o
}

// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
func (o VpcAccessibleServicesResponseOutput) AllowedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VpcAccessibleServicesResponse) []string { return v.AllowedServices }).(pulumi.StringArrayOutput)
}

// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
func (o VpcAccessibleServicesResponseOutput) EnableRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v VpcAccessibleServicesResponse) bool { return v.EnableRestriction }).(pulumi.BoolOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BasicLevelInput)(nil)).Elem(), BasicLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicLevelPtrInput)(nil)).Elem(), BasicLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionInput)(nil)).Elem(), ConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionArrayInput)(nil)).Elem(), ConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomLevelInput)(nil)).Elem(), CustomLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomLevelPtrInput)(nil)).Elem(), CustomLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePolicyInput)(nil)).Elem(), DevicePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePolicyPtrInput)(nil)).Elem(), DevicePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprPtrInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OsConstraintInput)(nil)).Elem(), OsConstraintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OsConstraintArrayInput)(nil)).Elem(), OsConstraintArray{})
	pulumi.RegisterOutputType(BasicLevelOutput{})
	pulumi.RegisterOutputType(BasicLevelPtrOutput{})
	pulumi.RegisterOutputType(BasicLevelResponseOutput{})
	pulumi.RegisterOutputType(ConditionOutput{})
	pulumi.RegisterOutputType(ConditionArrayOutput{})
	pulumi.RegisterOutputType(ConditionResponseOutput{})
	pulumi.RegisterOutputType(ConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(CustomLevelOutput{})
	pulumi.RegisterOutputType(CustomLevelPtrOutput{})
	pulumi.RegisterOutputType(CustomLevelResponseOutput{})
	pulumi.RegisterOutputType(DevicePolicyOutput{})
	pulumi.RegisterOutputType(DevicePolicyPtrOutput{})
	pulumi.RegisterOutputType(DevicePolicyResponseOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(ExprResponseOutput{})
	pulumi.RegisterOutputType(OsConstraintOutput{})
	pulumi.RegisterOutputType(OsConstraintArrayOutput{})
	pulumi.RegisterOutputType(OsConstraintResponseOutput{})
	pulumi.RegisterOutputType(OsConstraintResponseArrayOutput{})
	pulumi.RegisterOutputType(ServicePerimeterConfigResponseOutput{})
	pulumi.RegisterOutputType(VpcAccessibleServicesResponseOutput{})
}
